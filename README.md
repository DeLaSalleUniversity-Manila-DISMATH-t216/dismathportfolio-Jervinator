# dismathportfolio-Jervinator
dismathportfolio-Jervinator created by Classroom for GitHub
#Week 1
After the orientation, I realized how challenging Dismath really is
The first topic that was discussed were about **Truths** and its classifications are:
- **Legal Truth**
- **Authorative Truth**
- **Scientific Truth**
- **Probable Truth**
- **Philosophical Truth**

Having been introduced to the basic logic functions, the lesson became like a review for me.

However even with the knowledge of these logic functions, deep analysis is still a skill for Dismath.

Overall, I learned how challenging Dismath will be this first week.

#Week 2
- I was refreshed on what propositions are and what are its logical equivalences.
- Though I was already familiar with logical functions, the concept of proposition is different and this is where the topic for Quiz 1 revolves.
- I learned the equivalent equation for propositions and this helps simplify complex logical statements
- I learned the difference between universal and existential quantifiers and how they are used in mathematical equations
- The rules of inference were explained to me in detail and little by little I'm beginning to understand it
- Basic Logic Theorems

|         Name        |                           Equivalence                          |	
|:-------------------:|:--------------------------------------------------------------:|
|    Identity laws    |                      p ∧ T ≡ p<br>p v F ≡ p               |
|   Domination laws   |                       p v T ≡ T<br>p ∧ F ≡ F               |
|    Negation laws    |                     p v ¬p ≡ T<br>p ∧ ¬p ≡ F                   |
|   De Morgan's laws  |              ¬(p ∧ q) ≡ ¬p v ¬q<br>¬(p v q) ≡ ¬p ∧ ¬q      |    |
| Double negation law |                            ¬(¬p) ≡ p                           |
|   Idempotent laws   |                       p v p ≡ p<br>p ∧ p ≡ p               |
|   Commutative laws  |                   p v q ≡ q v p<br>p ∧ q ≡ q ∧ p               |
|   Associative laws  |       (p v q) v r ≡ p v (q v r)<br>(p ∧ q) ∧ r ≡ p ∧ (q ∧ r)   |
|  Distributive laws  | p v (q ∧ r) ≡ (p v q) ∧ (p v r)<br>p ∧(q v r) ≡ (p ∧ q) v (p ∧ r) |
|   Absorption laws   |                 p v (p ∧ q) ≡ p<br>p ∧ (p v q) ≡ p          |   |

#Week 3
The **Rules for Inference** was further discussed and ellaborated and they are:
- **Modus ponens**
- **Modus tollens**
- **Hyopthetical Syllogism**
- **Disjunctive Syllogism**
- **Addition**
- **Simplification**
- **Conjunction**
- **Resolution**

The examples the rules for inference puzzled the class but it still managaeable to learn when understood fully.

#Week 4
For this week the **Methods of Proof** were discussed and they are:
- **Direct Proof**
- **Contraposition**
- **Vacuous Proof**
- **Trivial Proof**

and the concept of *Proof by Contradiction* was introduced but not furtherly discussed yet.

A lot of examples were given for the methods of proof and this is a big help in understanding them further.

#Week 5
- Methods of Proof are emphasized in class because it is very important in Quiz 1 and this helped me learn the basics better
- The **Biconditional Statement** was discussed and when their are 2 statements p and q, both statements must be true when p implies q and q implies p. 
- Induction and Recursive were also discussed and examples for these 2 topics confused the class.

#Week 6
- Examples on Methods of Induction were given to the class and this confused all of us
- Induction has 2 steps
  - Basis Step - this proves whether the given is initially true (Show P(1) ≡ T)
  - Inductive Step - this proves whether the sequence is obediently true (Show that is also P(k+1) true)
- Program Verification was also taught this week and it is based on the basic rules of inference
- It has a process or method called Hoarse Triple wherein it is just a combination of direct proofs
- Hoarse Triple
  - p { S } q = T
  - Functions were introduced to the class and it has three kinds, **One-to-One** , **Onto** , and **Bijection**
    - **One-to-One** is also called Injective Function wherein some functions never assign the same value to two different domain elements.
    - **Onto** also called as Surjective Function exists if and only if for every element
b ∈ B there is an element a ∈ A with f (a) = b
   - **Bijective** occurs if it is both one-to-one and
onto.

#Week 7
 -  No classes

#Week 8
 - Algorithms were introduced to the class and it was very confusing.
 - Pseudocodes were also taught and this challenged the class because we were asked to create pseudocodes for basic programs like finding the max and in in a set of numbers, finding a number in an array with the use of binary and linear search.
 - There are different properties needed when creating a pseudocode and these are:
 - Input. An algorithm has input values from a specified set.
    - Output. From each set of input values an algorithm produces output values from a specified
set. The output values are the solution to the problem.
    - Definiteness. The steps of an algorithm must be defined precisely.
    - Correctness. An algorithm should produce the correct output values for each set of input
values.
    - Finiteness. An algorithm should produce the desired output after a finite (but perhaps
large) number of steps for any input in the set.
    - Effectiveness. It must be possible to perform each step of an algorithm exactly and in a
finite amount of time.
    - Generality. The procedure should be applicable for all problems of the desired form, not
just for a particular set of input values.

#Week9
   - Searching Algorithms were further introduced to the class like Linear and Binary Searchh
   - Sorting Algorithms were also taught and a video of people dancing about these algorithms made it clearer.
   - There are two types of sorting algorithm:
      - **Bubble Sort** - the simplest of all the sorting algorithms but no the most efficient
      - **Insertion Sort** -  also a simple algorithm but not efficient
  - Greedy Algorithm was introduced and it is used to find the most optimal solution to a program.

#Week 10
   - Growth of functions are taught throughout the week. It uses different notations like Big-O, Big-Omega and Big-Theta
   - Big-O Notation is used extensively to estimate the number of operations an algorithm uses
as its input grows.
    - Big-Omega Notation is used when the lower bound is needed while Big-Theta is used when both upper and lower bound is needed.
    - There are different kinds of complexities and this was discussed during this week:

|         Complexity        |                           Termninology                         |	
|:-------------------:|:--------------------------------------------------------------:|
|    Big Theta of 1      |                     Constant Complexity                          |
|    Big Theta of log(n)   |                   Logarithmic Complexity                     |
|    Big Theta of n      |                     Linear Complexity                             |
|    Big Theta of n log(n) |                   Linearithmic Complexity                             |
|    Big Theta of 1       |                    Polynomial Complexity                      |
|    Big Theta of b^n     |                    Exponential Complexity                         |
|    Big Theta of n!       |                   Factorial Complexity                           |


#Week 11
   - No Class

#Week 12
    - Graph Theory is the main topic for this week
    - A graph is defined as a structure that has edges and degrees and can either be finite or infinite.
    - Applications of Graphs were presented to the class and most of them are in the field of software applications particularly in social networking sites.
    - Paths and Circuits were also differentiated as paths cover all the edges of the graph while circuits cover all the edges and return to its starting point.
    - As a practice for paths and circuits, the Bridges of Konisberg was presented to the class and we were asked to determine if there is a path or a circuit there.
    - Euler Paths and Circuits were discussed and this was the proof that there is no path nor circuit in the Bridges of Konisberg 
    - To have an Euler Path the graph must only have 2 odd vertices while to have an Euler Circuit, all of the graph's vertices should be even.
   - Hamilton Path and Circuits were also tackled and their difference between Euler's is that Hamilton takes into consideration the nodes of the graph and not its edges.
   - Isomorphism and Planar Graphs were also taught and a sub-related topic to this is Kuratowski's Theorem

#Week 13
   - Graph Coloring was the first topic of the week and it seems to be challenging when the graphs gets more complex
   - Different kinds of trees were discussed and this was the rooted tree, m-ary tree and ordered tree.
   - Automata Theory and Finite State Machines were discussed and these were the final topic for the course

#Additional Readings
    - Tree Traversal - is a form of graph traversal and refers to the process of visiting each node in a tree data structure, exactly once
    - Spanning Tree - exists when it spans the given graph and is a subgraph of it too.
    - Relations - Relationship of elements between two sets
    - Properties
      - Binary - set A to set B is a subset of A x B
      - Reflexive - if (a, a) is an element of R for every element a in set A
      - Symmetric - if (b, a) is an element of R whenever (a, b) is an element of R, for all a, b in set A (antisymmetric if a = b)
      - Transitive - whenever (a, b) and (b, c) are elements of R then (a, c) is an element of R (a, b, c are in set A)
      - Equivalence - is reflexive, symmetric and transitive;
    - Equivalence Class (a) -set of all elements that are related to an element of A
    - N-ary - The relationship of elements from more than two sets; A1 x A2 x An, where A - domains and n - degree
    - Composite (S o R) - (a, b) and (b, c) are elements of R, then (a, c) is an element of R from sets A, B and C
    - Partial Ordering - Reflective, antisymmetric and transitive relation on a set S
    - Poset -a set taken together with a partial order on it. 
    - Lexicographic Order - a generalization of the way the alphabetical order of words is based on the alphabetical order of their component letters.
    - Lattices - consists of a partially ordered set in which every two elements, least upper bound or join and greatest lower bound or meet.
    - 
